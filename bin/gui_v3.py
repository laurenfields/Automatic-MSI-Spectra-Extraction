
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path
from tkinter.filedialog import askopenfilename
from tkinter import *
from PIL import ImageTk, Image,ImageOps
import PIL
#import backend
import threading
#from backend import *
from tkinter import messagebox
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import make_pipeline
from sklearn.impute import SimpleImputer
import umap
from matplotlib.backends.backend_tkagg import (
    FigureCanvasTkAgg, NavigationToolbar2Tk)
# Implement the default Matplotlib key bindings.
from matplotlib.backend_bases import key_press_handler
from matplotlib.figure import Figure
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import RandomizedSearchCV, train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, recall_score, ConfusionMatrixDisplay
from sklearn.neural_network import MLPClassifier
from sklearn.linear_model import LogisticRegression
import math
import warnings
from tkinter import ttk
from pyimzml.ImzMLParser import ImzMLParser
from pyimzml.ImzMLParser import getionimage
import matplotlib.pyplot as plt
import numpy as np
import csv
import pandas as pd
from scipy import ndimage
from scipy.ndimage import median_filter
from cycler import cycler
import seaborn as sns
from tkinter import *
from PIL import ImageTk, Image,ImageOps
from tkinter.filedialog import askopenfilename
from tkinter import filedialog
import webbrowser
from pyimzml.ImzMLParser import ImzMLParser
from pyimzml.ImzMLParser import getionimage
import matplotlib.pyplot as plt
#from zoom_test2 import CanvasImage

##define window
Font_tuple = ("Corbel Light", 20)
window = Tk()
window.title('MSI Parser')
window.iconbitmap(r"assets\cell_icon.ico")

window.geometry("1400x408")
window.configure(bg = "#FFFFFF")


###

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path("./assets")
##Variable storage
maldi_path_storage = StringVar()
optical_path_storage = StringVar()
export_path_storage = StringVar()
cell_mz_list_storage = StringVar()
bgrd_mz_list_storage = StringVar()
mz_value_storage = StringVar()
bgrd_mz_value_storage = StringVar()
resolution_storage = StringVar()
intensity_storage = StringVar()
charge_storage = StringVar()
tolerance_storage = StringVar()
median_size_storage = StringVar()
bin_step_size_storage = StringVar()
min_cell_size_storage = StringVar()
max_cell_size_storage = StringVar()
cell_remove_storage = StringVar()
latest_step_var = StringVar()
weight_avg = IntVar()
min_mz_range = IntVar()
max_mz_range = IntVar()
weight_avg.set(0)
results_csv = StringVar()
tnse_components = IntVar()
tnse_state = IntVar()
pca_components = IntVar()
rf_test_size = StringVar()
rf_depth = IntVar()
rf_ran_state = IntVar()

tnse_components.set(2)
tnse_state.set(0)
pca_components.set(2)
rf_test_size.set('0.2')
rf_depth.set(2)
rf_ran_state.set(0)
#results_csv.set(r"C:\Users\lawashburn\Documents\MSI_test\python_scripts\matched_52panc_52psc_data_sum60ppm_withtypes.csv")

##Definition storage


def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)
def openweb_liweb():
    new = 1
    url = "https://www.lilabs.org/resources"
    webbrowser.open(url,new=new)

def openweb_git():
    new = 1
    url = "https://github.com/lingjunli-research"
    webbrowser.open(url,new=new)

def openweb_user_manual():
    new = 1
    url = "https://docs.google.com/document/d/e/2PACX-1vRrgDIFa6F4b0zrk17eIXs0yTOz_GnE_3yM3Xh0Y-GIOc5z6GrMPfU-NDT47dus9JDHo7PkNj46jjvF/pub"
    webbrowser.open(url,new=new)

def show_optical_image(imagefile):
    image = ImageTk.PhotoImage(file=imagefile)
    optical_label.config(image=image)
    optical_label.image = image # save a reference of the image to avoid garbage collection

class AutoScrollbar(ttk.Scrollbar):
    """ A scrollbar that hides itself if it's not needed. Works only for grid geometry manager """
    def set(self, lo, hi):
        if float(lo) <= 0.0 and float(hi) >= 1.0:
            self.grid_remove()
        else:
            self.grid()
            ttk.Scrollbar.set(self, lo, hi)

    def pack(self, **kw):
        raise tk.TclError('Cannot use pack with the widget ' + self.__class__.__name__)

    def place(self, **kw):
        raise tk.TclError('Cannot use place with the widget ' + self.__class__.__name__)


def check_cell_mz_selection():
    str_cell_select = mz_settings_var.get()
    list_str_cell_select = str_cell_select.split(',')
    float_list_str_cell_select = []
    for a in list_str_cell_select:
        float_list_str_cell_select.append(float(a))

def parse_imzml(path):
    #import MSI data
    f = ImzMLParser(path) #ibd path required to parse
    return f
def check_cell_mz(path,string_mz_list,mz,tol,z,parsed_imzml,intensity_thresh):    #check_cell_mz
    string_split_mz_list = string_mz_list.split(",")
    mz_list = []
    for k in string_split_mz_list:
        mz_list.append(float(k))
    primary_img = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
    primary_img[primary_img < intensity_thresh] = 0
    for mz in mz_list:
        ind = mz_list.index(mz)
        img = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
        img[img < intensity_thresh] = 0
        plt.imshow(img,  interpolation='nearest')
        primary_img = np.add(img,primary_img)
    #plt.clf()
    plt.imshow(primary_img,  interpolation='nearest')
    plt.colorbar()
    plt.savefig('maldi_added.png')
    # img=Image.open('maldi_added.png') # read the image file
    # root.img=ImageTk.PhotoImage(img)
    # change_pic(root.img)
    return primary_img
def check_background_mz(path,string_mz_list,mz,tol,z,parsed_imzml):    #check_cell_mz
    # path = input_maldi_text.get()
    # string_mz_list = mz_bkgd_settings_var.get()
    string_split_mz_list = string_mz_list.split(",")
    mz_list = []
    for k in string_split_mz_list:
        mz_list.append(float(k))
    primary_img2 = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
    for mz in mz_list:
        ind = mz_list.index(mz)
        img = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
        primary_img = np.add(img,primary_img2)
    plt.clf()
    plt.imshow(primary_img2,  interpolation='nearest')
    plt.colorbar()
    plt.savefig('background_added.png')
    # img=Image.open('background_added.png') # read the image file
    # root.img=ImageTk.PhotoImage(img)
    # change_pic(root.img)
    background_array_storage = primary_img
    return primary_img

def maldi_plot_app(array,plot,title):
    root = Tk()
    root.wm_title(title)
   
    root.iconbitmap(r"assets\LiClaw.ico")

    fig = Figure(figsize=(5, 4), dpi=100)

    ax = fig.add_subplot(111)
    ax.imshow(array, interpolation='nearest')
    plt.colorbar()
    plt.tight_layout()

    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    canvas.draw()
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=1)

    toolbar = NavigationToolbar2Tk(canvas, root)
    toolbar.update()
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=1)


    def on_key_press(event):
        print("you pressed {}".format(event.key))
        key_press_handler(event, canvas, toolbar)


    canvas.mpl_connect("key_press_event", on_key_press)


    def _quit():
        root.quit()     # stops mainloop
        root.destroy()  # this is necessary on Windows to prevent
                        # Fatal Python Error: PyEval_RestoreThread: NULL tstate


    button = Button(master=root, text="Quit", command=_quit)
    button.pack(side=BOTTOM)

    root.mainloop()

def make_plot(array,fig,title):
    #from matplotlib_interactor_test import maldi_plot_app
    maldi_plot_app(array,fig,title)

def binarize_cells(step,foreground_img,bkgd_img):
    average_bkrd = np.average(bkgd_img)
    std_bkrd = np.std(bkgd_img)
    bkrd_intensity = (average_bkrd+std_bkrd)*step
    foreground_img[foreground_img <= bkrd_intensity] = 0
    foreground_img[foreground_img > 0] = 1
    plt.clf()
    fig = plt.figure(figsize = (6, 4))
    plt.imshow(foreground_img, interpolation='nearest')
    plt.colorbar()
    plt.tight_layout()
    plt.savefig('assets\\binarized_cells.png')
    return foreground_img
    #make_plot(fig)
def binarize_cells_w_pop(array,title):
    plt.clf()
    fig = plt.figure(figsize = (6, 4))
    plt.imshow(array, interpolation='nearest')
    plt.colorbar()
    plt.tight_layout()
    make_plot(array,fig,title)

def remove_cellular_holes(binarized_img):
    cellular_holeless_image = ndimage.binary_fill_holes(binarized_img).astype(int) #removes any holes in the interior of a cell
    plt.clf()
    plt.imshow(cellular_holeless_image, interpolation='nearest')
    plt.colorbar()
    plt.tight_layout()
    plt.savefig('assets\\cell_fill_holes.png')
    # img_png=Image.open('cell_fill_holes.png') # read the image file
    # root.img_png=ImageTk.PhotoImage(img_png)
    # change_pic(root.img_png)
    return cellular_holeless_image

def apply_median_filter_cells(filter_size,holes_filled):
    filtered_array = median_filter(holes_filled, size=filter_size) #remove any "speckles" or regions of just one or two pixels
    plt.clf()
    plt.imshow(filtered_array, interpolation='nearest')
    plt.colorbar()
    plt.savefig('assets\\median_filtered_cells.png')
    return filtered_array
def find_cell (img,i):
    # find cell areas - pixel with intensity >= given i
    # intensities of non-cell pixels are set to 0, return as 2D numpy array
    img_cell = img
    img_cell[img_cell<i] = 0
    return(img_cell)

def dfs(img_cell):
    # depth first search used to find (x,y) of each cell
    # return a list of (x,y) coordinates for each cell
    # first set cell=1 and non-cell=0
    grid = img_cell
    grid[grid != 0]=1
    seen = set()
    l_all = list()
    for r0, row in enumerate(grid):
        for c0, val in enumerate(row):
            l = list()
            if val and (r0, c0) not in seen:
                stack = [(r0, c0)]
                seen.add((r0, c0))
                l.append((r0,c0))
                while stack:
                    r, c = stack.pop()
                    for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                        if (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] and (nr, nc) not in seen):
                            stack.append((nr, nc))
                            seen.add((nr, nc))
                            l.append((nr,nc))
            l_all.append(l)
    return list(filter(None, l_all))

def initial_define_find_cells(filtered_array):
    # determine if each pixel is a cell or not
    img_cell = find_cell(filtered_array,1)
    # split to each cell area
    cc = dfs(img_cell)
    cell_localization_df = pd.DataFrame(columns=['x','y','cell_num'])
    i = 1 # cell number
    for l in cc:
        for x,y in l:
            cell_localization_df.loc[len(cell_localization_df.index)] = [y, x, i] 
        i = i+1
    cell_localization_df['t'] = cell_localization_df['cell_num'].astype('category')
    plt.clf()
    # sns.scatterplot('x', 'y', data=cell_localization_df, hue='t',linewidth=0, palette="deep")
    # plt.legend(loc='upper left',ncol=4, title="Cell #",bbox_to_anchor=(1, 1),fontsize='small',title_fontsize='medium')
    x_values_filtered = cell_localization_df['x'].values.tolist()
    y_values_filtered = cell_localization_df['y'].values.tolist()
    t_values_filtered = cell_localization_df['t'].values.tolist()

    t_values_filtered_str = []
    for a in t_values_filtered:
        t_values_filtered_str.append(str(a))

    sns.scatterplot(x=x_values_filtered, y=y_values_filtered, hue=t_values_filtered_str,linewidth=0, palette='husl')

    plt.legend(loc='upper left',ncol=2, title="Cell #",bbox_to_anchor=(1, 1),fontsize='small',title_fontsize='medium')

    plt.savefig('inital_cells_define.png', bbox_inches = 'tight')
    plt.clf()
    img_png=Image.open('inital_cells_define.png') # read the image file
    img_png = ImageOps.contain(img_png, (500,400))

    root.img_png=ImageTk.PhotoImage(img_png)
    change_pic(root.img_png)
    return cell_localization_df

def area_filter_cells(min_cell_pixels,max_cell_pixels,filtered_array):
    # determine if each pixel is a cell or not
    img_cell = find_cell(filtered_array,1)
    # split to each cell area
    cc = dfs(img_cell)
    cell_localization_df = pd.DataFrame(columns=['x','y','cell_num'])
    i = 1 # cell number
    for l in cc:
        for x,y in l:
            cell_localization_df.loc[len(cell_localization_df.index)] = [y, x, i] 
        i = i+1
    cell_localization_df['t'] = cell_localization_df['cell_num'].astype('category')
    #print(len(cell_localization_df))
    cell_numbers = cell_localization_df['t'].values.tolist()
    cell_number_no_dups = []
    for aa in cell_numbers:
        if aa not in cell_number_no_dups:
            cell_number_no_dups.append(aa)
    
    filtered_cells = pd.DataFrame()  
    for bb in cell_number_no_dups:
        cell_local_filter = cell_localization_df[cell_localization_df['t'] == bb]
        if len(cell_local_filter) >=min_cell_pixels:
            if len(cell_local_filter) <=max_cell_pixels:
                filtered_cells = pd.concat([filtered_cells,cell_local_filter])
            else:
                pass
        else:
            pass
    filtered_cells['g'] = filtered_cells['t'].astype('category') 
    plt.clf()
    filtered_cells_clean = filtered_cells.copy()
    x_values_filtered = filtered_cells_clean['x'].values.tolist()
    y_values_filtered = filtered_cells_clean['y'].values.tolist()
    t_values_filtered = filtered_cells_clean['t'].values.tolist()
    t_values_filtered_str = []
    for a in t_values_filtered:
        t_values_filtered_str.append(str(a))

    sns.scatterplot(x=x_values_filtered, y=y_values_filtered, hue=t_values_filtered_str,linewidth=0, palette='husl')
    plt.gca().invert_yaxis()
    plt.legend(loc='upper left',ncol=2, title="Cell #",bbox_to_anchor=(1, 1),fontsize='small',title_fontsize='medium')
    #plt.legend()
    plt.savefig('assets\\area_filtered_cells.png', bbox_inches = 'tight')
    plt.clf()
    return filtered_cells_clean

def remove_cell_by_number(cells_to_remove,filtered_cells2):
    cells_to_remove = cells_to_remove.split(",")
    cells_IDs = []
    for x in cells_to_remove:
        cells_IDs.append(int(x))
    if len(cells_IDs)>0:
        filtered_cells2 = filtered_cells2[~filtered_cells2['t'].isin(cells_IDs)]
    else:
        pass
    filtered_cells2['i'] = filtered_cells2['t'].astype('category')    
    plt.clf()    
    x_values = filtered_cells2['x'].values.tolist()
    y_values = filtered_cells2['y'].values.tolist()
    t_values = filtered_cells2['i'].values.tolist()  
    t_values_str = []
    for m in t_values:
        t_values_str.append(str(m))    
    sns.scatterplot(x=x_values, y=y_values, hue=t_values_str,linewidth=0, palette="husl")
    plt.gca().invert_yaxis()
    plt.legend(loc='upper left',ncol=2, title="Cell #",bbox_to_anchor=(1, 1),fontsize='small',title_fontsize='medium')
    plt.savefig('assets\\manual_filtered_cells.png', bbox_inches = 'tight')
    return filtered_cells2
def mzbin(mz,intensity,start,end,resolution):
    # mz is an array of m/z values of a mass spectrum at some pixel
    # intensity is an array of corresponding intensities
    # start and end are the lower and upper bound m/z
    # resolution defines res of mass binning
    # returns result_mz: if a bin has edges 0.1-0.2, returns its center 0.15
    # result_intensity: the average intensity of every value falls into that bin
    result_mz=[]
    result_intensity=[]
    # step=(end-start)/resolution
    sort_mz=[x for x,_ in sorted(zip(mz,intensity))]
    sort_inten=[y for _,y in sorted(zip(mz,intensity))]
    HIST_BINS = np.linspace(start, end, resolution)
    n, m = np.histogram(sort_mz, HIST_BINS)
    counter=0
    for i in range(len(n)):
        hist_val=sort_inten[counter:counter+n[i]]
        if len(hist_val)==0:
            result_intensity.append(0)
        else:
            avg=np.average(hist_val)
            result_intensity.append(avg)

        result_mz.append((m[i]+m[i+1])/2)
        counter+=n[i]
    return result_mz,result_intensity
def export_spectra(filtered_cells2,path,weighted_avg,output_spectra_path,min_mz,max_mz,resolution):
    filtered_cells2["Identifier"] = filtered_cells2['x'].astype(str) +"_"+ filtered_cells2["y"].astype(str)
    cell_IDs = filtered_cells2['Identifier'].values.tolist()
    cell_ID_report = []
    cell_ID_count = []   
    for cc in cell_IDs:
        cell_count = cell_IDs.count(cc)
        cell_ID_report.append(cc)
        cell_ID_count.append(cell_count)        
    cell_count_report = pd.DataFrame()
    cell_count_report['ID'] = cell_ID_report
    cell_count_report['Count'] = cell_ID_count   
    filtered_cells2['coordinate count'] = cell_ID_count
    filtered_cells2 = filtered_cells2[filtered_cells2['coordinate count'] == 1]
    filtered_cells2['t'] = filtered_cells2['cell_num'].astype('category')    

    f = parse_imzml(path)
    # dict - {x,y: index}
    # a dictionary of pixel information
    coord_dict = {}
    for i in range(len(f.coordinates)):
        coord_dict[(f.coordinates[i][0],f.coordinates[i][1])]= i
    final_cell_list_dups = filtered_cells2['t'].values.tolist()

    final_cell_list = []
    for l in final_cell_list_dups:
        if l not in final_cell_list:
            final_cell_list.append(l)
        else:
            pass
    if weighted_avg==1:    
        final_report = pd.DataFrame()
        for m in final_cell_list:
            cell=filtered_cells2.loc[filtered_cells2['t'] == m]
            # do mass binning for each pixel in a cell, then calculate the average mass spectrum
            total_intensity=0
            output_intensity=[]
            output_mz=[]
            for i in range(len(cell)):
                try:
                    xx=cell.iloc[i]['x']
                    yy=cell.iloc[i]['y']
                    index=coord_dict[(xx+1,yy+1)]
                    mz, intensity = ImzMLParser.getspectrum(f,index) # retrieve mass spectrum at a pixel
                    sum_intensity=sum(intensity)
                    total_intensity+=sum_intensity
                    result_mz,result_intensity=mzbin(mz, intensity, min_mz,max_mz,resolution)
                    # print(result_mz,result_intensity)
                    # print(sum_intensity)
                    # calculate weighted average: sum(intensity of each cell * total intensity)/sum(total intensity)
                    result_intensity=np.asarray(result_intensity)*sum_intensity 
                    output_intensity.append(result_intensity)
                    output_mz=result_mz
                except Exception:
                    pass
            output=np.sum(output_intensity,axis=0)/total_intensity
            
            plt.plot(output_mz,output)
            plt.title("Cell #: "+str(m))
            file_name = output_spectra_path + "cell_number_" + str(m) + ".png" 
            plt.savefig(file_name)
    
            output_df = pd.DataFrame()
            output_df['m/z'] = output_mz
            output_df[("Cell #: " + str(m))] = output
            #output_df['cell_number'] = m
            if len(final_report)>0:
                final_report = final_report.merge(output_df,on='m/z',how='outer')
            else:
                final_report = pd.concat([final_report,output_df])
    
            plt.close()
        file_path = output_spectra_path + 'avg_spectra_all.csv'
        with open(file_path,'w',newline='') as filec:
                    writerc = csv.writer(filec)
                    final_report.to_csv(filec,index=False)
    
    if weighted_avg==0:
        final_report = pd.DataFrame()
        for m in final_cell_list:
            cell_one=filtered_cells2.loc[filtered_cells2['t'] == m]

            total_intensity=0
            output_intensity=[]
            output_mz=[]
            for i in range(len(cell_one)):
                try:
                    xx=cell_one.iloc[i]['x']
                    yy=cell_one.iloc[i]['y']
                    index=coord_dict[(xx+1,yy+1)]
                    mz, intensity = ImzMLParser.getspectrum(f,index) # retrieve mass spectrum at a pixel
                    
                    sum_intensity=sum(intensity)
                    total_intensity+=sum_intensity
                    
                    result_mz,result_intensity=mzbin(mz, intensity,min_mz,max_mz,resolution)

                    # result_intensity=np.asarray(result_intensity)*sum_intensity 
                    output_intensity.append(result_intensity)
                    output_mz=(result_mz)
                except Exception:
                    pass
            
            output=np.sum(output_intensity,axis=0)/total_intensity
            plt.plot(output_mz,output)
            plt.title("Cell #: "+str(m))
            file_name = output_spectra_path + "\\cell_number_" + str(m) + ".png" 
            plt.savefig(file_name)
            output_df = pd.DataFrame()
            output_df['m/z'] = output_mz
            output_df[("Cell #: " + str(m))] = output
            #output_df['cell_number'] = m
            if len(final_report)>0:
                final_report = final_report.merge(output_df,on='m/z',how='outer')
            else:
                final_report = pd.concat([final_report,output_df])
            
            plt.close()
        file_path = output_spectra_path + '\\avg_spectra_all.csv'
        with open(file_path,'w',newline='') as filec:
                    writerc = csv.writer(filec)
                    final_report.to_csv(filec,index=False)
        
        final_report_transposed = final_report.transpose()
        final_report_transposed.reset_index(inplace=True)
        final_report_transposed = final_report_transposed.iloc[1:]
        
        file_path = output_spectra_path + '\\statistics_report.csv'
        with open(file_path,'w',newline='') as filec:
                    writerc = csv.writer(filec)
                    final_report_transposed.to_csv(filec,index=False)
        

def check_cell_mz_verify(path,string_split_mz_list,mz,tol,z,parsed_imzml):    #check_cell_mz
    mz_list = []
    for k in string_split_mz_list:
        mz_list.append(float(k))
    primary_img2 = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
    for mz in mz_list:
        ind = mz_list.index(mz)
        img = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
        plt.imshow(img,  interpolation='nearest')
        primary_img2 = np.add(img,primary_img2)
        plt_path = str(ind) + '_img.png'
        plt.savefig(plt_path)
    plt.clf()
    plt.imshow(primary_img2,  interpolation='nearest')
    plt.colorbar()
    plt.savefig('assets\\maldi_added.png')
    return primary_img2

def check_background_mz_verify(path,string_split_mz_list,mz,tol,z,parsed_imzml):    #check_cell_mz
    print('here')
    mz_list = []
    for k in string_split_mz_list:
        mz_list.append(float(k))
    # mz = float(primary_background_mz.get())
    # tol = float(tolerance_choice.get())
    # z = int(z_choice.get())
    # parsed_imzml = parse_imzml(path)
    primary_img = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
    for mz in mz_list:
        ind = mz_list.index(mz)
        img = getionimage(parsed_imzml, mz, tol, z,reduce_func=sum) # img stored as 2D numpy array
        plt.imshow(img,  interpolation='nearest')
        primary_img = np.add(img,primary_img)
        plt_path = str(ind) + '_img.png'
        plt.savefig(plt_path)
    plt.clf()
    plt.imshow(primary_img,  interpolation='nearest')
    plt.colorbar()
    plt.savefig('assets\\background_added.png')
    return primary_img

class CanvasImage:
    """ Display and zoom image """
    def __init__(self, placeholder, path):
        """ Initialize the ImageFrame """
        self.imscale = 1.0  # scale for the canvas image zoom, public for outer classes
        self.__delta = 1.3  # zoom magnitude
        self.__filter = Image.ANTIALIAS  # could be: NEAREST, BILINEAR, BICUBIC and ANTIALIAS
        self.__previous_state = 0  # previous state of the keyboard
        self.path = path  # path to the image, should be public for outer classes
        # Create ImageFrame in placeholder widget
        self.__imframe = ttk.Frame(placeholder)  # placeholder of the ImageFrame object
        # Vertical and horizontal scrollbars for canvas
        hbar = AutoScrollbar(self.__imframe, orient='horizontal')
        vbar = AutoScrollbar(self.__imframe, orient='vertical')
        hbar.grid(row=1, column=0, sticky='we')
        vbar.grid(row=0, column=1, sticky='ns')
        # Create canvas and bind it with scrollbars. Public for outer classes
        self.canvas = Canvas(self.__imframe, highlightthickness=0,
                                xscrollcommand=hbar.set, yscrollcommand=vbar.set)
        self.canvas.grid(row=0, column=0, sticky='nswe')
        self.canvas.update()  # wait till canvas is created
        hbar.configure(command=self.__scroll_x)  # bind scrollbars to the canvas
        vbar.configure(command=self.__scroll_y)
        # Bind events to the Canvas
        self.canvas.bind('<Configure>', lambda event: self.__show_image())  # canvas is resized
        self.canvas.bind('<ButtonPress-1>', self.__move_from)  # remember canvas position
        self.canvas.bind('<B1-Motion>',     self.__move_to)  # move canvas to the new position
        self.canvas.bind('<MouseWheel>', self.__wheel)  # zoom for Windows and MacOS, but not Linux
        self.canvas.bind('<Button-5>',   self.__wheel)  # zoom for Linux, wheel scroll down
        self.canvas.bind('<Button-4>',   self.__wheel)  # zoom for Linux, wheel scroll up
        # Handle keystrokes in idle mode, because program slows down on a weak computers,
        # when too many key stroke events in the same time
        self.canvas.bind('<Key>', lambda event: self.canvas.after_idle(self.__keystroke, event))
        # Decide if this image huge or not
        self.__huge = False  # huge or not
        self.__huge_size = 14000  # define size of the huge image
        self.__band_width = 1024  # width of the tile band
        Image.MAX_IMAGE_PIXELS = 1000000000  # suppress DecompressionBombError for the big image
        with warnings.catch_warnings():  # suppress DecompressionBombWarning
            warnings.simplefilter('ignore')
            self.__image = Image.open(self.path)  # open image, but down't load it
        self.imwidth, self.imheight = self.__image.size  # public for outer classes
        if self.imwidth * self.imheight > self.__huge_size * self.__huge_size and \
           self.__image.tile[0][0] == 'raw':  # only raw images could be tiled
            self.__huge = True  # image is huge
            self.__offset = self.__image.tile[0][2]  # initial tile offset
            self.__tile = [self.__image.tile[0][0],  # it have to be 'raw'
                           [0, 0, self.imwidth, 0],  # tile extent (a rectangle)
                           self.__offset,
                           self.__image.tile[0][3]]  # list of arguments to the decoder
        self.__min_side = min(self.imwidth, self.imheight)  # get the smaller image side
        # Create image pyramid
        self.__pyramid = [self.smaller()] if self.__huge else [Image.open(self.path)]
        # Set ratio coefficient for image pyramid
        self.__ratio = max(self.imwidth, self.imheight) / self.__huge_size if self.__huge else 1.0
        self.__curr_img = 0  # current image from the pyramid
        self.__scale = self.imscale * self.__ratio  # image pyramide scale
        self.__reduction = 2  # reduction degree of image pyramid
        w, h = self.__pyramid[-1].size
        while w > 512 and h > 512:  # top pyramid image is around 512 pixels in size
            w /= self.__reduction  # divide on reduction degree
            h /= self.__reduction  # divide on reduction degree
            self.__pyramid.append(self.__pyramid[-1].resize((int(w), int(h)), self.__filter))
        # Put image into container rectangle and use it to set proper coordinates to the image
        self.container = self.canvas.create_rectangle((0, 0, self.imwidth, self.imheight), width=0)
        self.__show_image()  # show image on the canvas
        self.canvas.focus_set()  # set focus on the canvas

    def smaller(self):
        """ Resize image proportionally and return smaller image """
        w1, h1 = float(self.imwidth), float(self.imheight)
        w2, h2 = float(self.__huge_size), float(self.__huge_size)
        aspect_ratio1 = w1 / h1
        aspect_ratio2 = w2 / h2  # it equals to 1.0
        if aspect_ratio1 == aspect_ratio2:
            image = Image.new('RGB', (int(w2), int(h2)))
            k = h2 / h1  # compression ratio
            w = int(w2)  # band length
        elif aspect_ratio1 > aspect_ratio2:
            image = Image.new('RGB', (int(w2), int(w2 / aspect_ratio1)))
            k = h2 / w1  # compression ratio
            w = int(w2)  # band length
        else:  # aspect_ratio1 < aspect_ration2
            image = Image.new('RGB', (int(h2 * aspect_ratio1), int(h2)))
            k = h2 / h1  # compression ratio
            w = int(h2 * aspect_ratio1)  # band length
        i, j, n = 0, 1, round(0.5 + self.imheight / self.__band_width)
        while i < self.imheight:
            print('\rOpening image: {j} from {n}'.format(j=j, n=n), end='')
            band = min(self.__band_width, self.imheight - i)  # width of the tile band
            self.__tile[1][3] = band  # set band width
            self.__tile[2] = self.__offset + self.imwidth * i * 3  # tile offset (3 bytes per pixel)
            self.__image.close()
            self.__image = Image.open(self.path)  # reopen / reset image
            self.__image.size = (self.imwidth, band)  # set size of the tile band
            self.__image.tile = [self.__tile]  # set tile
            cropped = self.__image.crop((0, 0, self.imwidth, band))  # crop tile band
            image.paste(cropped.resize((w, int(band * k)+1), self.__filter), (0, int(i * k)))
            i += band
            j += 1
        print('\r' + 30*' ' + '\r', end='')  # hide printed string
        return image

    def redraw_figures(self):
        """ Dummy function to redraw figures in the children classes """
        pass

    def grid(self, **kw):
        """ Put CanvasImage widget on the parent widget """
        self.__imframe.grid(**kw)  # place CanvasImage widget on the grid
        self.__imframe.grid(sticky='nswe')  # make frame container sticky
        self.__imframe.rowconfigure(0, weight=1)  # make canvas expandable
        self.__imframe.columnconfigure(0, weight=1)

    def pack(self, **kw):
        """ Exception: cannot use pack with this widget """
        raise Exception('Cannot use pack with the widget ' + self.__class__.__name__)

    def place(self, **kw):
        """ Exception: cannot use place with this widget """
        raise Exception('Cannot use place with the widget ' + self.__class__.__name__)

    # noinspection PyUnusedLocal
    def __scroll_x(self, *args, **kwargs):
        """ Scroll canvas horizontally and redraw the image """
        self.canvas.xview(*args)  # scroll horizontally
        self.__show_image()  # redraw the image

    # noinspection PyUnusedLocal
    def __scroll_y(self, *args, **kwargs):
        """ Scroll canvas vertically and redraw the image """
        self.canvas.yview(*args)  # scroll vertically
        self.__show_image()  # redraw the image

    def __show_image(self):
        """ Show image on the Canvas. Implements correct image zoom almost like in Google Maps """
        box_image = self.canvas.coords(self.container)  # get image area
        box_canvas = (self.canvas.canvasx(0),  # get visible area of the canvas
                      self.canvas.canvasy(0),
                      self.canvas.canvasx(self.canvas.winfo_width()),
                      self.canvas.canvasy(self.canvas.winfo_height()))
        box_img_int = tuple(map(int, box_image))  # convert to integer or it will not work properly
        # Get scroll region box
        box_scroll = [min(box_img_int[0], box_canvas[0]), min(box_img_int[1], box_canvas[1]),
                      max(box_img_int[2], box_canvas[2]), max(box_img_int[3], box_canvas[3])]
        # Horizontal part of the image is in the visible area
        if  box_scroll[0] == box_canvas[0] and box_scroll[2] == box_canvas[2]:
            box_scroll[0]  = box_img_int[0]
            box_scroll[2]  = box_img_int[2]
        # Vertical part of the image is in the visible area
        if  box_scroll[1] == box_canvas[1] and box_scroll[3] == box_canvas[3]:
            box_scroll[1]  = box_img_int[1]
            box_scroll[3]  = box_img_int[3]
        # Convert scroll region to tuple and to integer
        self.canvas.configure(scrollregion=tuple(map(int, box_scroll)))  # set scroll region
        x1 = max(box_canvas[0] - box_image[0], 0)  # get coordinates (x1,y1,x2,y2) of the image tile
        y1 = max(box_canvas[1] - box_image[1], 0)
        x2 = min(box_canvas[2], box_image[2]) - box_image[0]
        y2 = min(box_canvas[3], box_image[3]) - box_image[1]
        if int(x2 - x1) > 0 and int(y2 - y1) > 0:  # show image if it in the visible area
            if self.__huge and self.__curr_img < 0:  # show huge image
                h = int((y2 - y1) / self.imscale)  # height of the tile band
                self.__tile[1][3] = h  # set the tile band height
                self.__tile[2] = self.__offset + self.imwidth * int(y1 / self.imscale) * 3
                self.__image.close()
                self.__image = Image.open(self.path)  # reopen / reset image
                self.__image.size = (self.imwidth, h)  # set size of the tile band
                self.__image.tile = [self.__tile]
                image = self.__image.crop((int(x1 / self.imscale), 0, int(x2 / self.imscale), h))
            else:  # show normal image
                image = self.__pyramid[max(0, self.__curr_img)].crop(  # crop current img from pyramid
                                    (int(x1 / self.__scale), int(y1 / self.__scale),
                                     int(x2 / self.__scale), int(y2 / self.__scale)))
            #
            imagetk = ImageTk.PhotoImage(image.resize((int(x2 - x1), int(y2 - y1)), self.__filter))
            imageid = self.canvas.create_image(max(box_canvas[0], box_img_int[0]),
                                               max(box_canvas[1], box_img_int[1]),
                                               anchor='nw', image=imagetk)
            self.canvas.lower(imageid)  # set image into background
            self.canvas.imagetk = imagetk  # keep an extra reference to prevent garbage-collection

    def __move_from(self, event):
        """ Remember previous coordinates for scrolling with the mouse """
        self.canvas.scan_mark(event.x, event.y)

    def __move_to(self, event):
        """ Drag (move) canvas to the new position """
        self.canvas.scan_dragto(event.x, event.y, gain=1)
        self.__show_image()  # zoom tile and show it on the canvas

    def outside(self, x, y):
        """ Checks if the point (x,y) is outside the image area """
        bbox = self.canvas.coords(self.container)  # get image area
        if bbox[0] < x < bbox[2] and bbox[1] < y < bbox[3]:
            return False  # point (x,y) is inside the image area
        else:
            return True  # point (x,y) is outside the image area

    def __wheel(self, event):
        """ Zoom with mouse wheel """
        x = self.canvas.canvasx(event.x)  # get coordinates of the event on the canvas
        y = self.canvas.canvasy(event.y)
        if self.outside(x, y): return  # zoom only inside image area
        scale = 1.0
        # Respond to Linux (event.num) or Windows (event.delta) wheel event
        if event.num == 5 or event.delta == -120:  # scroll down, smaller
            if round(self.__min_side * self.imscale) < 30: return  # image is less than 30 pixels
            self.imscale /= self.__delta
            scale        /= self.__delta
        if event.num == 4 or event.delta == 120:  # scroll up, bigger
            i = min(self.canvas.winfo_width(), self.canvas.winfo_height()) >> 1
            if i < self.imscale: return  # 1 pixel is bigger than the visible area
            self.imscale *= self.__delta
            scale        *= self.__delta
        # Take appropriate image from the pyramid
        k = self.imscale * self.__ratio  # temporary coefficient
        self.__curr_img = min((-1) * int(math.log(k, self.__reduction)), len(self.__pyramid) - 1)
        self.__scale = k * math.pow(self.__reduction, max(0, self.__curr_img))
        #
        self.canvas.scale('all', x, y, scale, scale)  # rescale all objects
        # Redraw some figures before showing image on the screen
        self.redraw_figures()  # method for child classes
        self.__show_image()

    def __keystroke(self, event):
        """ Scrolling with the keyboard.
            Independent from the language of the keyboard, CapsLock, <Ctrl>+<key>, etc. """
        if event.state - self.__previous_state == 4:  # means that the Control key is pressed
            pass  # do nothing if Control key is pressed
        else:
            self.__previous_state = event.state  # remember the last keystroke state
            # Up, Down, Left, Right keystrokes
            if event.keycode in [68, 39, 102]:  # scroll right: keys 'D', 'Right' or 'Numpad-6'
                self.__scroll_x('scroll',  1, 'unit', event=event)
            elif event.keycode in [65, 37, 100]:  # scroll left: keys 'A', 'Left' or 'Numpad-4'
                self.__scroll_x('scroll', -1, 'unit', event=event)
            elif event.keycode in [87, 38, 104]:  # scroll up: keys 'W', 'Up' or 'Numpad-8'
                self.__scroll_y('scroll', -1, 'unit', event=event)
            elif event.keycode in [83, 40, 98]:  # scroll down: keys 'S', 'Down' or 'Numpad-2'
                self.__scroll_y('scroll',  1, 'unit', event=event)

    def crop(self, bbox):
        """ Crop rectangle from the image and return it """
        if self.__huge:  # image is huge and not totally in RAM
            band = bbox[3] - bbox[1]  # width of the tile band
            self.__tile[1][3] = band  # set the tile height
            self.__tile[2] = self.__offset + self.imwidth * bbox[1] * 3  # set offset of the band
            self.__image.close()
            self.__image = Image.open(self.path)  # reopen / reset image
            self.__image.size = (self.imwidth, band)  # set size of the tile band
            self.__image.tile = [self.__tile]
            return self.__image.crop((bbox[0], 0, bbox[2], band))
        else:  # image is totally in RAM
            return self.__pyramid[0].crop(bbox)

    def destroy(self):
        """ ImageFrame destructor """
        self.__image.close()
        map(lambda i: i.close, self.__pyramid)  # close all pyramid images
        del self.__pyramid[:]  # delete pyramid list
        del self.__pyramid  # delete pyramid variable
        self.canvas.destroy()
        self.__imframe.destroy()

class MainWindow(ttk.Frame):
    """ Main window class """
    def __init__(self, mainframe, path):
        """ Initialize the main Frame """
        ttk.Frame.__init__(self, master=mainframe)
        self.master.title('Optical Viewer')
        self.master.geometry('520x370')  # size of the main window
        self.master.iconbitmap(r"assets\LiClaw.ico")
        self.master.rowconfigure(0, weight=1)  # make the CanvasImage widget expandable
        self.master.columnconfigure(0, weight=1)
        canvas = CanvasImage(self.master, path)  # create widget
        canvas.grid(row=0, column=0)  # show widget

def app_call(filename):
    app = MainWindow(Toplevel(), path=filename)
    app.mainloop()


def show_maldi_image(imagefile):
    image = ImageTk.PhotoImage(file=imagefile)
    maldi_label.config(image=image)
    maldi_label.image = image # save a reference of the image to avoid garbage collection

def determine_optical_frame():
    value = optical_path_storage.get()
    if len(value) > 1:
        path_to_show = value
    else:
        path_to_show = 'assets\\microscope_small.png'
    return path_to_show


def set_spectral_file_file():
    maldi_path = askopenfilename(filetypes=[("MSI Files",("*.imzML"))]) 
    maldi_path_storage.set(maldi_path)
    
def set_export_folder():
    path_out_dir = filedialog.askdirectory() 
    export_path_storage.set(path_out_dir)
    
def set_optical_image_field():

    path_optical = askopenfilename(filetypes=[("Image Files",("*.png","*.jpeg","*.TIF"))]) 
    optical_path_storage.set(path_optical)

    photo_choice = determine_optical_frame()
    
    microscope_image1 = Image.open(
        relative_to_assets(photo_choice))
    w, h = microscope_image1.size
    if w>360:
        ratio = 360/w
        #print(ratio)
    elif h>308:
        ratio = 360/h
    else:
        ratio=1 
    new_width = int(w*ratio)
    new_height = int(h*ratio)
    microscope_image2=microscope_image1.resize((new_width,new_height),Image.ANTIALIAS)
    im1 = microscope_image2.save('assets\\optical_test2.png')
    show_optical_image(relative_to_assets("optical_test2.png"))
    show_optical_image(relative_to_assets("optical_test2.png"))


def start_binarized_cell_search_w_pop(array,title):
    # path = maldi_path_storage.get()
    # cell_string_mz_list = cell_mz_list_storage.get()
    # cell_mz = float(mz_value_storage.get())
    # bkgd_string_mz_list = bgrd_mz_list_storage.get()
    # bkgd_mz = float(bgrd_mz_value_storage.get())
    # tol = float(tolerance_storage.get())
    # z = int(charge_storage.get())
    # parsed_imzml = parse_imzml(path)
    # foreground_img = check_cell_mz(path,cell_string_mz_list,cell_mz,tol,z,parsed_imzml)    
    # bkgd_img = check_background_mz(path,bkgd_string_mz_list,bkgd_mz,tol,z,parsed_imzml) 
    binarized_cells = binarize_cells_w_pop(array,title)

def maldi_plot_app_df(array,plot,title):
    root = Tk()
    root.wm_title(title)
   
    root.iconbitmap(r"assets\LiClaw.ico")

    fig = Figure(figsize=(5, 4), dpi=100)

    
    # ax.imshow(array, interpolation='nearest')
    # plt.colorbar()
    # plt.tight_layout()
    
    x_values_filtered = array['x'].values.tolist()
    y_values_filtered = array['y'].values.tolist()
    t_values_filtered = array['t'].values.tolist()
    t_values_filtered_str = []
    for a in t_values_filtered:
        t_values_filtered_str.append(str(a))
    ax = fig.add_subplot(111)
    sns.scatterplot(ax=ax, x=x_values_filtered, y=y_values_filtered, hue=t_values_filtered_str,linewidth=0, palette='husl')
    #plt.gca().invert_yaxis()
    ax.invert_yaxis()
    # #sns.set_palette("pastel")
    ax.legend(loc='upper left',ncol=2, title="Cell #",bbox_to_anchor=(1, 1),fontsize='small',title_fontsize='medium')

    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    canvas.draw()
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=1)

    toolbar = NavigationToolbar2Tk(canvas, root)
    toolbar.update()
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=1)


    def on_key_press(event):
        print("you pressed {}".format(event.key))
        key_press_handler(event, canvas, toolbar)


    canvas.mpl_connect("key_press_event", on_key_press)


    def _quit():
        root.quit()     # stops mainloop
        root.destroy()  # this is necessary on Windows to prevent
                        # Fatal Python Error: PyEval_RestoreThread: NULL tstate


    button = Button(master=root, text="Quit", command=_quit)
    button.pack(side=BOTTOM)

    root.mainloop()

def make_plot_df(array,fig,title):
    #from matplotlib_interactor_test import maldi_plot_app
    maldi_plot_app_df(array,fig,title)

def determine_maldi_frame():
    value = latest_step_var.get()
    #print(value)
    if value == 'binarized':
        path_to_show = 'binarized_cells.png'
    elif value == 'holes':
        path_to_show = 'cell_fill_holes.png'
    elif value == 'median':
        path_to_show = 'median_filtered_cells.png'
    elif value == 'define':
        path_to_show = 'area_filtered_cells.png'
    elif value == 'select_remove':
        path_to_show = 'manual_filtered_cells.png'
    else:
        path_to_show = 'maldi_logo.png'
    return path_to_show
def define_cells_pop(title):
    filtered_cells_clean = pd.read_pickle("defined_cells.pkl")
    x_values_filtered = filtered_cells_clean['x'].values.tolist()
    y_values_filtered = filtered_cells_clean['y'].values.tolist()
    t_values_filtered = filtered_cells_clean['t'].values.tolist()
    t_values_filtered_str = []
    for a in t_values_filtered:
        t_values_filtered_str.append(str(a))
    fig = plt.figure(figsize = (6, 4))
    sns.scatterplot(x=x_values_filtered, y=y_values_filtered, hue=t_values_filtered_str,linewidth=0, palette='husl')
    plt.gca().invert_yaxis()
    #sns.set_palette("pastel")
    plt.legend(loc='upper left',ncol=2, title="Cell #",bbox_to_anchor=(1, 1),fontsize='small',title_fontsize='medium')
    #plt.legend()
    make_plot_df(filtered_cells_clean,fig,title)

def select_remove_pop(title):
    filtered_cells_clean = pd.read_pickle("manually_removed_cells.pkl")
    x_values_filtered = filtered_cells_clean['x'].values.tolist()
    y_values_filtered = filtered_cells_clean['y'].values.tolist()
    t_values_filtered = filtered_cells_clean['t'].values.tolist()
    t_values_filtered_str = []
    for a in t_values_filtered:
        t_values_filtered_str.append(str(a))
    fig = plt.figure(figsize = (6, 4))
    sns.scatterplot(x=x_values_filtered, y=y_values_filtered, hue=t_values_filtered_str,linewidth=0, palette='husl')
    plt.gca().invert_yaxis()
    plt.legend(loc='upper left',ncol=2, title="Cell #",bbox_to_anchor=(1, 1),fontsize='small',title_fontsize='medium')

    make_plot_df(filtered_cells_clean,fig,title)
    
def execute_maldi_pop():
    last_execution = latest_step_var.get()
    if last_execution == 'binarized':
        load_path = last_execution + '_cell_array.npy'
        array = np.load(load_path)
        title = 'Binarized View'
        start_binarized_cell_search_w_pop(array,title)
    elif last_execution == 'holes':
        load_path = last_execution + '_cell_array.npy'
        array = np.load(load_path)
        title = 'Remove Holes View'
        start_binarized_cell_search_w_pop(array,title)
    elif last_execution == 'median':
        load_path = last_execution + '_cell_array.npy'
        array = np.load(load_path)
        title = 'Median Filter View'
        start_binarized_cell_search_w_pop(array,title)
    elif last_execution == 'define':
        title = 'Parsed Cells Viewer'
        define_cells_pop(title)
    elif last_execution == 'select_remove':
        title = 'Removed Cell Viewer'
        select_remove_pop(title)
    elif last_execution == 'cells_check':
        title = 'Cell m/z Check'
        array = np.load('mz_cell_array.npy')
        start_binarized_cell_search_w_pop(array,title)
    elif last_execution == 'background_check':
        title = 'Background m/z check'
        array = np.load('background_mz_array.npy')
        start_binarized_cell_search_w_pop(array,title)
    
    else:
        path_to_show = 'maldi_logo.png'

def set_maldi_image_field(image_path):
    maldi_image_path = determine_maldi_frame()
    maldi_image1 = Image.open(
        relative_to_assets(maldi_image_path))
    w, h = maldi_image1.size
    if w>360:
        ratio = 360/w
    elif h>308:
        ratio = 360/h
    else:
        ratio=1 
    new_width = int(w*ratio)
    new_height = int(h*ratio)
    
    maldi_image2=maldi_image1.resize((new_width,new_height),Image.ANTIALIAS)
    im1 = maldi_image2.save('assets\\maldi_image_resize.png')
    show_maldi_image(relative_to_assets("maldi_image_resize.png"))
    

def optical_pop_out():
    #from optical_zoom_window import app_call
    filename_path = determine_optical_frame()  # place path to your image here
    app_call(filename_path)

def start_binarized_cell_search():
    latest_step_var.set('binarized')
    path = maldi_path_storage.get()
    cell_string_mz_list = cell_mz_list_storage.get()
    cell_string_mz_list_split = cell_string_mz_list.split(',')
    cell_mz = float(mz_value_storage.get())
    bkgd_string_mz_list = bgrd_mz_list_storage.get()
    bkgd_string_mz_list_split = bkgd_string_mz_list.split(',')
    bkgd_mz = float(bgrd_mz_value_storage.get())
    tol = float(tolerance_storage.get())
    z = int(charge_storage.get())
    parsed_imzml = parse_imzml(path)
    intensity_thresh = int(intensity_storage.get())
    foreground_img = check_cell_mz(path,cell_string_mz_list,cell_mz,tol,z,parsed_imzml,intensity_thresh)    
    bkgd_img = check_background_mz(path,bkgd_string_mz_list,bkgd_mz,tol,z,parsed_imzml) 
    step = int(bin_step_size_storage.get())
    binarized_cells = binarize_cells(step,foreground_img,bkgd_img)
    set_maldi_image_field('binarized_cells.png')
    np.save('binarized_cell_array',binarized_cells)
    

def start_fill_holes_search():
    latest_step_var.set('holes')
    binarized_img = np.load('binarized_cell_array.npy')
    holy_image = remove_cellular_holes(binarized_img)
    np.save('holes_cell_array',holy_image)
    set_maldi_image_field('cell_fill_holes.png')

def start_median_filter_search():
    latest_step_var.set('median')
    holes_filled = np.load('holes_cell_array.npy')
    filter_size = int(median_size_storage.get())
    median_applied = apply_median_filter_cells(filter_size,holes_filled)
    np.save('median_cell_array',median_applied)
    set_maldi_image_field('median_filtered_cells.png')

def start_cell_define_area_filter_search():
    latest_step_var.set('define')
    filtered_array = np.load('median_cell_array.npy')
    min_cell_pixels = int(min_cell_size_storage.get())
    max_cell_pixels = int(max_cell_size_storage.get())
    filtered_cells = area_filter_cells(min_cell_pixels,max_cell_pixels,filtered_array)
    set_maldi_image_field('area_filtered_cells.png')
    filtered_cells.to_pickle("defined_cells.pkl")

def start_remove_cell_by_number():
    latest_step_var.set('select_remove')
    cells_to_remove = cell_remove_storage.get()
    filtered_cells = pd.read_pickle("defined_cells.pkl")
    manually_removed_cells = remove_cell_by_number(cells_to_remove,filtered_cells)
    set_maldi_image_field('manual_filtered_cells.png')
    manually_removed_cells.to_pickle("manually_removed_cells.pkl")

def start_export_spectra():
    last_step = latest_step_var.get()
    if last_step == 'define':
        filtered_cells = pd.read_pickle("defined_cells.pkl")
    elif last_step == 'select_remove':
        filtered_cells = pd.read_pickle("manually_removed_cells.pkl")
    else:
        messagebox.showerror('Order error', 'Cells must be defined')
    path = maldi_path_storage.get()
    weighted_avg = weight_avg.get()
    export_path = export_path_storage.get()
    min_mz = min_mz_range.get()
    max_mz = max_mz_range.get()
    resolution = int(resolution_storage.get())
    export_spectra(filtered_cells,path,weighted_avg,export_path,min_mz,max_mz,resolution)

def start_mz_list_check():
    latest_step_var.set('cells_check')
    path = maldi_path_storage.get()
    string_mz_list = cell_mz_list_storage.get()
    string_split_mz_list = string_mz_list.split(",")
    mz = float(mz_value_storage.get())
    tol = float(tolerance_storage.get())
    z = int(charge_storage.get())
    parsed_imzml = parse_imzml(path)
    mz_cell_array = check_cell_mz_verify(path,string_split_mz_list,mz,tol,z,parsed_imzml)
    np.save('mz_cell_array',mz_cell_array)
    execute_maldi_pop()

def start_background_mz_list_check():
    latest_step_var.set('background_check')
    path = maldi_path_storage.get()
    string_mz_list = bgrd_mz_list_storage.get()
    string_split_mz_list = string_mz_list.split(",")
    mz = float(bgrd_mz_value_storage.get())
    tol = float(tolerance_storage.get())
    z = int(charge_storage.get())
    parsed_imzml = parse_imzml(path)
    mz_cell_array = check_background_mz_verify(path,string_split_mz_list,mz,tol,z,parsed_imzml)
    np.save('background_mz_array',mz_cell_array)
    execute_maldi_pop()
def set_results_file():
    results_path = askopenfilename(filetypes=[("Results Files",("*.csv"))]) 
    results_csv.set(results_path)


def start_UMAP_pop():
    csv_path = results_csv.get()
    tps = pd.read_csv(csv_path)
    tps.shape
    LE = LabelEncoder()
    tps['CellType'] = LE.fit_transform(tps['CellType'])
    tps=tps.iloc[: , 1:]
    tps = tps.astype(float)
    # Sample the data - 100k
    X_2, y = tps.drop("CellType", axis=1), tps[["CellType"]].values.flatten()
    pipe = make_pipeline(SimpleImputer(strategy="mean"))
    X_2 = pipe.fit_transform(X_2.copy())

    manifold = umap.UMAP().fit(X_2, y)
    X_2_reduced = manifold.transform(X_2)
    X_2_reduced.shape
    fig = plt.figure(figsize = (6, 4))
    plt.scatter(X_2_reduced[:, 0], X_2_reduced[:, 1], c=y, s=10);
    plt.title("UMAP Reduction")
    title = "UMAP Reduction"
    root = Tk()
    root.wm_title(title)
    root.iconbitmap(r"assets\LiClaw.ico")
    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    toolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)
    toolbar.update()
    toolbar.pack(side=BOTTOM, fill=X)
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=True)
    root.mainloop()
def make_umap():
    umap_window = Toplevel(window)
    umap_window.title("UMAP analysis")
    umap_window.geometry("575x100")
    umap_window.iconbitmap(r"assets\LiClaw.ico")
    Label(umap_window,
          text ="Results file from analysis:").place(x=5.0,
          y=25.0,
          width=246.0,
          height=15.0)
    entry_1 = Entry(umap_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=results_csv
    )
    entry_1.place(x=200.0,
        y=25.0,
        width=246.0,
        height=15.0)
    button_image_6 = PhotoImage(
        file=("assets\\button_6.png"))
    button_6 = Button(umap_window,
        image=button_image_6,
        borderwidth=0,
        highlightthickness=0,
        command=set_results_file,
        relief="flat",
        bg='#D5C9D6')
    button_6.place(x=450.0,
          y=25.0,
          width=50.0,
          height=18.0)
    button_image_analysis = PhotoImage(
        file=("assets\\begin_analysis_button.png"))
    button_7 = Button(umap_window,
        image=button_image_analysis,
        borderwidth=0,
        highlightthickness=0,
        command=start_UMAP_pop,
        relief="flat",
        bg='#D5C9D6')
    button_7.place(x=250.0,
          y=50.0,
          width=103.0,
          height=17.0)
    umap_window.mainloop()

def start_tnse_pop():
    csv_path = results_csv.get()
    tps = pd.read_csv(csv_path)
    tps.shape
    LE = LabelEncoder()
    tps['CellType'] = LE.fit_transform(tps['CellType'])
    tps=tps.iloc[: , 1:]
    tps = tps.astype(float)
    # Sample the data - 100k
    X_2, y = tps.drop("CellType", axis=1), tps[["CellType"]].values.flatten()
    pipe = make_pipeline(SimpleImputer(strategy="mean"))
    X_2 = pipe.fit_transform(X_2.copy())
    n_comp = tnse_components.get()
    ran_state = tnse_state.get()
    X_2_embedded = TSNE(n_components=n_comp, learning_rate='auto',random_state=ran_state).fit_transform(X_2)
    X_2_embedded.shape
    fig = plt.figure(figsize = (6, 4))
    plt.scatter(X_2_embedded[:, 0], X_2_embedded[:, 1], c=y, s=10);
    plt.title("TSNE Reduction")

    title = "TSNE Reduction"
    root = Tk()
    root.wm_title(title)
    root.iconbitmap(r"assets\LiClaw.ico")
    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    toolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)
    toolbar.update()
    toolbar.pack(side=BOTTOM, fill=X)
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=True)
    root.mainloop()

def make_tsne():
    tnse_window = Toplevel(window)
    tnse_window.title("TSNE analysis")
    tnse_window.geometry("575x200")
    tnse_window.iconbitmap(r"assets\LiClaw.ico")
    Label(tnse_window,
          text ="Results file from analysis:").place(x=5.0,
          y=25.0,
          width=246.0,
          height=15.0)
    entry_1 = Entry(tnse_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=results_csv
    )
    entry_1.place(x=200.0,
        y=25.0,
        width=246.0,
        height=15.0)
    button_image_6 = PhotoImage(
        file=("assets\\button_6.png"))
    button_6 = Button(tnse_window,
        image=button_image_6,
        borderwidth=0,
        highlightthickness=0,
        command=set_results_file,
        relief="flat",
        bg='#D5C9D6')
    button_6.place(x=450.0,
          y=25.0,
          width=50.0,
          height=18.0)
    button_image_analysis = PhotoImage(
        file=("assets\\begin_analysis_button.png"))
    button_7 = Button(tnse_window,
        image=button_image_analysis,
        borderwidth=0,
        highlightthickness=0,
        command=start_tnse_pop,
        relief="flat",
        bg='#D5C9D6')
    button_7.place(x=250.0,
          y=100.0,
          width=103.0,
          height=17.0)
    Label(tnse_window,
          text ="# Components:").place(x=50.0,
          y=60.0,
          width=100.0,
          height=15.0)
    entry_1 = Entry(tnse_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=tnse_components
    )
    entry_1.place(x=150.0,
        y=60.0,
        width=50.0,
        height=20.0)   
    Label(tnse_window,
          text ="Random state:").place(x=200.0,
          y=60.0,
          width=100.0,
          height=15.0)
    entry_1 = Entry(tnse_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=tnse_state
    )
    entry_1.place(x=300.0,
        y=60.0,
        width=50.0,
        height=20.0)                                 
    tnse_window.mainloop()    

def start_pca_pop():
    csv_path = results_csv.get()
    tps = pd.read_csv(csv_path)
    tps.shape
    LE = LabelEncoder()
    tps['CellType'] = LE.fit_transform(tps['CellType'])
    tps=tps.iloc[: , 1:]
    tps = tps.astype(float)
    # Sample the data - 100k
    X_2, y = tps.drop("CellType", axis=1), tps[["CellType"]].values.flatten()
    pipe = make_pipeline(SimpleImputer(strategy="mean"))
    fig = plt.figure(figsize = (6, 4))
    pca = PCA(n_components=pca_components.get())
    X_2_pca =pca.fit_transform(X_2)
    plt.scatter(X_2_pca[:, 0], X_2_pca[:, 1], c=y, s=10);
    plt.title("PCA Reduction")
    title = "PCA Reduction"
    root = Tk()
    root.wm_title(title)
    root.iconbitmap(r"assets\LiClaw.ico")
    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    toolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)
    toolbar.update()
    toolbar.pack(side=BOTTOM, fill=X)
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=True)
    root.mainloop()

def make_pca():
    pca_window = Toplevel(window)
    pca_window.title("PCA analysis")
    pca_window.geometry("575x200")
    pca_window.iconbitmap(r"assets\LiClaw.ico")
    Label(pca_window,
          text ="Results file from analysis:").place(x=5.0,
          y=25.0,
          width=246.0,
          height=15.0)
    entry_1 = Entry(pca_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=results_csv
    )
    entry_1.place(x=200.0,
        y=25.0,
        width=246.0,
        height=15.0)
    button_image_6 = PhotoImage(
        file=("assets\\button_6.png"))
    button_6 = Button(pca_window,
        image=button_image_6,
        borderwidth=0,
        highlightthickness=0,
        command=set_results_file,
        relief="flat",
        bg='#D5C9D6')
    button_6.place(x=450.0,
          y=25.0,
          width=50.0,
          height=18.0)
    button_image_analysis = PhotoImage(
        file=("assets\\begin_analysis_button.png"))
    button_7 = Button(pca_window,
        image=button_image_analysis,
        borderwidth=0,
        highlightthickness=0,
        command=start_pca_pop,
        relief="flat",
        bg='#D5C9D6')
    button_7.place(x=250.0,
          y=100.0,
          width=103.0,
          height=17.0)
    Label(pca_window,
          text ="# Components:").place(x=50.0,
          y=60.0,
          width=100.0,
          height=15.0)
    entry_1 = Entry(pca_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=pca_components
    )
    entry_1.place(x=150.0,
        y=60.0,
        width=50.0,
        height=20.0)
    pca_window.mainloop() 

def start_rf_pop():
    csv_path = results_csv.get()
    tps = pd.read_csv(csv_path)
    tps.shape
    LE = LabelEncoder()
    tps['CellType'] = LE.fit_transform(tps['CellType'])
    tps=tps.iloc[: , 1:]
    tps = tps.astype(float)
    # Sample the data - 100k
    X_2, y = tps.drop("CellType", axis=1), tps[["CellType"]].values.flatten()
    pipe = make_pipeline(SimpleImputer(strategy="mean"))
    fig = plt.figure(figsize = (6, 4))
    
    max_dep_get = rf_depth.get()
    ran_state_get = rf_ran_state.get()
    test_size_get = float(rf_test_size.get())
    
    X_train, X_test, y_train, y_test = train_test_split(X_2, y, test_size=test_size_get)
    clf = RandomForestClassifier(max_depth=max_dep_get, random_state=ran_state_get)
    clf.fit(X_train, y_train)

    y_pred = clf.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    print("Accuracy:", accuracy)
    confusion_matrix(y_test, y_pred)

    y_pred = clf.predict(X_test)
    conf_matrix = confusion_matrix(y_true=y_test, y_pred=y_pred)
    #
    # Print the confusion matrix using Matplotlib
    #
    fig, ax = plt.subplots(figsize=(7.5, 7.5))
    ax.matshow(conf_matrix, cmap=plt.cm.Blues, alpha=0.3)
    for i in range(conf_matrix.shape[0]):
        for j in range(conf_matrix.shape[1]):
            ax.text(x=j, y=i,s=conf_matrix[i, j], va='center', ha='center', size='xx-large')
     
    plt.xlabel('Predictions\naccuracy={:0.4f}'.format(accuracy), fontsize=18)
    plt.ylabel('Actuals', fontsize=18)
    plt.title('Confusion Matrix', fontsize=18)
    
    title = "Random Forest Confusion Matrix"
    root = Tk()
    root.wm_title(title)
    root.iconbitmap(r"assets\LiClaw.ico")
    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    toolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)
    toolbar.update()
    toolbar.pack(side=BOTTOM, fill=X)
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=True)
    root.mainloop()

def make_rf():
    rf_window = Toplevel(window)
    rf_window.title("Random Forest Classifier")
    rf_window.geometry("575x200")
    rf_window.iconbitmap(r"assets\LiClaw.ico")
    Label(rf_window,
          text ="Results file from analysis:").place(x=5.0,
          y=25.0,
          width=246.0,
          height=15.0)
    entry_1 = Entry(rf_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=results_csv
    )
    entry_1.place(x=200.0,
        y=25.0,
        width=246.0,
        height=15.0)
    button_image_6 = PhotoImage(
        file=("assets\\button_6.png"))
    button_6 = Button(rf_window,
        image=button_image_6,
        borderwidth=0,
        highlightthickness=0,
        command=set_results_file,
        relief="flat",
        bg='#D5C9D6')
    button_6.place(x=450.0,
          y=25.0,
          width=50.0,
          height=18.0)
    button_image_analysis = PhotoImage(
        file=("assets\\begin_analysis_button.png"))
    button_7 = Button(rf_window,
        image=button_image_analysis,
        borderwidth=0,
        highlightthickness=0,
        command=start_rf_pop,
        relief="flat",
        bg='#D5C9D6')
    button_7.place(x=250.0,
          y=100.0,
          width=103.0,
          height=17.0)
    Label(rf_window,
          text ="Test size:").place(x=50.0,
          y=60.0,
          width=100.0,
          height=15.0)
    entry_1 = Entry(rf_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=rf_test_size
    )
    entry_1.place(x=150.0,
        y=60.0,
        width=50.0,
        height=20.0)   
    Label(rf_window,
          text ="Max depth:").place(x=200.0,
          y=60.0,
          width=100.0,
          height=15.0)
    entry_1 = Entry(rf_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=rf_depth
    )
    entry_1.place(x=300.0,
        y=60.0,
        width=50.0,
        height=20.0) 
    Label(rf_window,
          text ="Random state:").place(x=350.0,
          y=60.0,
          width=100.0,
          height=15.0)
    entry_1 = Entry(rf_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=rf_ran_state
    )
    entry_1.place(x=450.0,
        y=60.0,
        width=50.0,
        height=20.0)
    rf_window.mainloop() 

def start_mlp_pop():
    csv_path = results_csv.get()
    tps = pd.read_csv(csv_path)
    tps.shape
    LE = LabelEncoder()
    tps['CellType'] = LE.fit_transform(tps['CellType'])
    tps=tps.iloc[: , 1:]
    tps = tps.astype(float)
    # Sample the data - 100k
    X_2, y = tps.drop("CellType", axis=1), tps[["CellType"]].values.flatten()
    pipe = make_pipeline(SimpleImputer(strategy="mean"))
    fig = plt.figure(figsize = (6, 4))
    
    X_train, X_test, y_train, y_test = train_test_split(X_2, y, test_size=0.2)
    clf = RandomForestClassifier(max_depth=2, random_state=0)
    clf.fit(X_train, y_train)
    model2 = MLPClassifier().fit(X_train, y_train)
    y_pred3 = model2.predict(X_test)

    accuracy3 = accuracy_score(y_test, y_pred3)
    print("Accuracy:", accuracy3)
    confusion_matrix(y_test, y_pred3)

    y_pred = clf.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    print("Accuracy:", accuracy)
    confusion_matrix(y_test, y_pred)

    y_pred = clf.predict(X_test)
    conf_matrix = confusion_matrix(y_true=y_test, y_pred=y_pred)
    fig, ax = plt.subplots(figsize=(7.5, 7.5))
    ax.matshow(conf_matrix, cmap=plt.cm.Blues, alpha=0.3)
    for i in range(conf_matrix.shape[0]):
        for j in range(conf_matrix.shape[1]):
            ax.text(x=j, y=i,s=conf_matrix[i, j], va='center', ha='center', size='xx-large')
     
    plt.xlabel('Predictions\naccuracy={:0.4f}'.format(accuracy), fontsize=18)
    plt.ylabel('Actuals', fontsize=18)
    plt.title('Confusion Matrix', fontsize=18)
    
    title = "MLPConfusion Matrix"
    root = Tk()
    root.wm_title(title)
    root.iconbitmap(r"assets\LiClaw.ico")
    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    toolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)
    toolbar.update()
    toolbar.pack(side=BOTTOM, fill=X)
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=True)
    root.mainloop()


def make_mlp():
    mlp_window = Toplevel(window)
    mlp_window.title("MLPClassifier")
    mlp_window.geometry("575x100")
    mlp_window.iconbitmap(r"assets\LiClaw.ico")
    Label(mlp_window,
          text ="Results file from analysis:").place(x=5.0,
          y=25.0,
          width=246.0,
          height=15.0)
    entry_1 = Entry(mlp_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=results_csv
    )
    entry_1.place(x=200.0,
        y=25.0,
        width=246.0,
        height=15.0)
    button_image_6 = PhotoImage(
        file=("assets\\button_6.png"))
    button_6 = Button(mlp_window,
        image=button_image_6,
        borderwidth=0,
        highlightthickness=0,
        command=set_results_file,
        relief="flat",
        bg='#D5C9D6')
    button_6.place(x=450.0,
          y=25.0,
          width=50.0,
          height=18.0)
    button_image_analysis = PhotoImage(
        file=("assets\\begin_analysis_button.png"))
    button_7 = Button(mlp_window,
        image=button_image_analysis,
        borderwidth=0,
        highlightthickness=0,
        command=start_mlp_pop,
        relief="flat",
        bg='#D5C9D6')
    button_7.place(x=250.0,
          y=50.0,
          width=103.0,
          height=17.0)
    mlp_window.mainloop() 

def start_lr_pop():
    csv_path = results_csv.get()
    tps = pd.read_csv(csv_path)
    tps.shape
    LE = LabelEncoder()
    tps['CellType'] = LE.fit_transform(tps['CellType'])
    tps=tps.iloc[: , 1:]
    tps = tps.astype(float)
    # Sample the data - 100k
    X_2, y = tps.drop("CellType", axis=1), tps[["CellType"]].values.flatten()
    pipe = make_pipeline(SimpleImputer(strategy="mean"))
    fig = plt.figure(figsize = (6, 4))
    
    X_train, X_test, y_train, y_test = train_test_split(X_2, y, test_size=0.2)
    clf = RandomForestClassifier(max_depth=2, random_state=0)
    clf.fit(X_train, y_train)
    model = LogisticRegression().fit(X_train, y_train)
    y_pred2= model.predict(X_test)
    accuracy2 = accuracy_score(y_test, y_pred2)
    print("Accuracy:", accuracy2)
    confusion_matrix(y_test, y_pred2)
    conf_matrix = confusion_matrix(y_true=y_test, y_pred=y_pred2)
    fig, ax = plt.subplots(figsize=(7.5, 7.5))
    ax.matshow(conf_matrix, cmap=plt.cm.Blues, alpha=0.3)
    for i in range(conf_matrix.shape[0]):
        for j in range(conf_matrix.shape[1]):
            ax.text(x=j, y=i,s=conf_matrix[i, j], va='center', ha='center', size='xx-large')
     
    plt.xlabel('Predictions\naccuracy={:0.4f}'.format(accuracy2), fontsize=18)
    plt.ylabel('Actuals', fontsize=18)
    plt.title('Confusion Matrix', fontsize=18)
    
    title = "Logistic Regression Matrix"
    root = Tk()
    root.wm_title(title)
    root.iconbitmap(r"assets\LiClaw.ico")
    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    toolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)
    toolbar.update()
    toolbar.pack(side=BOTTOM, fill=X)
    canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=True)
    root.mainloop()

def make_lr():
    lr_window = Toplevel(window)
    lr_window.title("Logistic Regression")
    lr_window.geometry("575x100")
    lr_window.iconbitmap(r"assets\LiClaw.ico")
    Label(lr_window,
          text ="Results file from analysis:").place(x=5.0,
          y=25.0,
          width=246.0,
          height=15.0)
    entry_1 = Entry(lr_window,
        bd=0,
        bg="white",
        highlightthickness=2,
        textvariable=results_csv
    )
    entry_1.place(x=200.0,
        y=25.0,
        width=246.0,
        height=15.0)
    button_image_6 = PhotoImage(
        file=("assets\\button_6.png"))
    button_6 = Button(lr_window,
        image=button_image_6,
        borderwidth=0,
        highlightthickness=0,
        command=set_results_file,
        relief="flat",
        bg='#D5C9D6')
    button_6.place(x=450.0,
          y=25.0,
          width=50.0,
          height=18.0)
    button_image_analysis = PhotoImage(
        file=("assets\\begin_analysis_button.png"))
    button_7 = Button(lr_window,
        image=button_image_analysis,
        borderwidth=0,
        highlightthickness=0,
        command=start_lr_pop,
        relief="flat",
        bg='#D5C9D6')
    button_7.place(x=250.0,
          y=50.0,
          width=103.0,
          height=17.0)
    lr_window.mainloop() 

menubar = Menu(window)
filemenu = Menu(menubar, tearoff=0)
filemenu.add_command(label="Exit", command=window.quit)
menubar.add_cascade(label="File", menu=filemenu)
helpmenu = Menu(menubar, tearoff=0)
helpmenu.add_command(label="Li Lab Website", command=openweb_liweb)
helpmenu.add_command(label="Li Lab GitHub", command=openweb_git)
helpmenu.add_command(label="User manual", command=openweb_user_manual)

toolmenu = Menu(menubar, tearoff=0)
#toolmenu.add_command(label="Coming soon")
toolmenu.add_command(label="UMAP Reduction", command=make_umap)
toolmenu.add_command(label="TSNE Reduction", command=make_tsne)
toolmenu.add_command(label="PCA Reduction", command=make_pca)
toolmenu.add_command(label="Random Forest Classifier", command=make_rf)
toolmenu.add_command(label="MLPClassifier", command=make_mlp)
toolmenu.add_command(label="Logistic Regression", command=make_lr)
menubar.add_cascade(label="Statistics", menu=toolmenu)
menubar.add_cascade(label="Help", menu=helpmenu)
window.config(menu=menubar)


canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 408,
    width = 1403,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
canvas.create_rectangle(
    1289.0,
    0.0,
    1402.0,
    408.0,
    fill="#5F4A61",
    outline="")

button_image_1 = PhotoImage(
    file=relative_to_assets("button_1.png"))
button_1 = Button(
    image=button_image_1,
    borderwidth=0,
    highlightthickness=0,
    command = start_binarized_cell_search,
    relief="flat"
)
button_1.place(
    x=1292.0,
    y=90.0,
    width=107.0,
    height=33.0
)

button_image_2 = PhotoImage(
    file=relative_to_assets("normalize_button.png"))
button_2 = Button(
    image=button_image_2,
    borderwidth=0,
    highlightthickness=0,
    command=start_fill_holes_search,
    relief="flat"
)
button_2.place(
    x=1293.0,
    y=135.0,
    width=107.0,
    height=40.0
)

button_image_3 = PhotoImage(
    file=relative_to_assets("button_3.png"))
button_3 = Button(
    image=button_image_3,
    borderwidth=0,
    highlightthickness=0,
    command=start_median_filter_search,
    relief="flat"
)
button_3.place(
    x=1293.0,
    y=179.0,
    width=107.0,
    height=40.0
)

button_image_4 = PhotoImage(
    file=relative_to_assets("button_4.png"))
button_4 = Button(
    image=button_image_4,
    borderwidth=0,
    highlightthickness=0,
    command=start_cell_define_area_filter_search,
    relief="flat"
)
button_4.place(
    x=1292.0,
    y=225.0,
    width=107.0,
    height=40.0
)

button_image_5 = PhotoImage(
    file=relative_to_assets("button_5.png"))
button_5 = Button(
    image=button_image_5,
    borderwidth=0,
    highlightthickness=0,
    command=start_export_spectra,
    relief="flat"
)
button_5.place(
    x=1293.0,
    y=269.0,
    width=107.0,
    height=40.0
)

canvas.create_rectangle(
    0.0,
    0.0,
    430.0,
    408.0,
    fill="#D5C9D6",
    outline="")

canvas.create_text(
    165.0,
    8.0,
    anchor="nw",
    text="Analysis Settings",
    fill="#000000",
    font=("HammersmithOne Regular", 16 * -1,'bold')
)

# entry_image_1 = PhotoImage(
#     file=relative_to_assets("entry_1.png"))
# entry_bg_1 = canvas.create_image(
#     243.0,
#     73.5,
#     image=entry_image_1
# )
entry_1 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable=maldi_path_storage
)
entry_1.place(
    x=120.0,
    y=65.0,
    width=246.0,
    height=15.0
)
#entry_1.insert(END,r"C:\Users\lawashburn\Documents\MSI_test\test_data_from_Hua\small_dataset_pos_20230216\psc_cell_ctrl_3-05-2022_smallarea021623.imzML")
button_image_6 = PhotoImage(
    file=relative_to_assets("button_6.png"))
button_6 = Button(
    image=button_image_6,
    borderwidth=0,
    highlightthickness=0,
    command=set_spectral_file_file,
    relief="flat",
    bg='#D5C9D6'
)
button_6.place(
    x=367.0,
    y=65.0,
    width=55.0,
    height=17.0
)

canvas.create_text(
    38.0,
    60.0,
    anchor="nw",
    text="Spectral file\n(.imzML)",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

# entry_image_2 = PhotoImage(
#     file=relative_to_assets("entry_2.png"))
# entry_bg_2 = canvas.create_image(
#     240.0,
#     385.5,
#     image=entry_image_2
# )
entry_2 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = export_path_storage
)
entry_2.place(
    x=117.0,
    y=377.0,
    width=246.0,
    height=15.0
)
#entry_2.insert(END,r"C:\Users\lawashburn\Documents\MSI_test\gui_test\20230411")
button_image_7 = PhotoImage(
    file=relative_to_assets("button_7.png"))
button_7 = Button(
    image=button_image_7,
    borderwidth=0,
    highlightthickness=0,
    command=set_export_folder,
    relief="flat",
    bg='#D5C9D6'
)
button_7.place(
    x=364.0,
    y=377.0,
    width=55.0,
    height=17.0
)

canvas.create_text(
    34.0,
    378.0,
    anchor="nw",
    text="Export folder",
    fill="#000000",
    font=("Inter", 12 * -1)
)

optical_label = Label(window,bg='#B19BB3')
optical_label.place(x=460.0,y=50.0,width=380.0,height=250.0)
show_optical_image(relative_to_assets("microscope_small.png"))

maldi_label = Label(window,bg='#8C6D8F')
maldi_label.place(x=900.0,y=50.0,width=380.0,height=250.0)
show_maldi_image(relative_to_assets("maldi_logo.png"))

button_image_1100 = PhotoImage(
    file=relative_to_assets("button_110.png"))
button_1100 = Button(
    image=button_image_1100,
    borderwidth=0,
    highlightthickness=0,
    command=execute_maldi_pop,
    relief="flat",
    bg='#8C6D8F')
button_1100.place(
    x=1050.0,
    y=300.0,
    width=55.0,
    height=17.0
)


button_image_8 = PhotoImage(
    file=relative_to_assets("button_8.png"))
button_8 = Button(
    image=button_image_8,
    borderwidth=0,
    highlightthickness=0,
    command=start_mz_list_check,
    relief="flat",
    bg='#D5C9D6'
)
button_8.place(
    x=367.0,
    y=230.0,
    width=55.0,
    height=17.0
)

# entry_image_3 = PhotoImage(
#     file=relative_to_assets("entry_3.png"))
# entry_bg_3 = canvas.create_image(
#     225.0,
#     249.5,
#     image=entry_image_3
# )
entry_3 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = cell_mz_list_storage
)
#entry_3.insert(END,'810.6052,632.6295,604.5808,760.5623,808.5812,788.5988,786.5904')
entry_3.place(
    x=87.0,
    y=230.0,
    width=276.0,
    height=15.0
)

canvas.create_text(
    17.0,
    226.0,
    anchor="nw",
    text="Cell m/z\nlist",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

button_image_9 = PhotoImage(
    file=relative_to_assets("button_9.png"))
button_9 = Button(
    image=button_image_9,
    borderwidth=0,
    highlightthickness=0,
    command=start_background_mz_list_check,
    relief="flat",
    bg='#D5C9D6'
)
button_9.place(
    x=367.0,
    y=270.0,
    width=55.0,
    height=17.0
)

# entry_image_4 = PhotoImage(
#     file=relative_to_assets("entry_4.png"))
# entry_bg_4 = canvas.create_image(
#     225.0,
#     287.5,
#     image=entry_image_4
# )
entry_4 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = bgrd_mz_list_storage
)
#entry_4.insert(END,'444.1061,614.1936,613.181,615.1925,595.178,596.1608,565.1754')
entry_4.place(
    x=87.0,
    y=270.0,
    width=276.0,
    height=15.0
)

canvas.create_text(
    9.0,
    265.0,
    anchor="nw",
    text="Background \nm/z list",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

# entry_image_5 = PhotoImage(
#     file=relative_to_assets("entry_5.png"))
# entry_bg_5 = canvas.create_image(
#     119.5,
#     131.5,
#     image=entry_image_5
# )
entry_5 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = mz_value_storage
)
#entry_5.insert(END,'810.6052')
entry_5.place(
    x=95.0,
    y=105.0,
    width=49.0,
    height=15.0
)

canvas.create_text(
    40.0,
    105.0,
    anchor="nw",
    text="m/z",
    fill="#000000",
    font=("Inter", 12 * -1)
)

# entry_image_6 = PhotoImage(
#     file=relative_to_assets("entry_6.png"))
# entry_bg_6 = canvas.create_image(
#     397.5,
#     175.5,
#     image=entry_image_6
# )
entry_6 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = bgrd_mz_value_storage
)
#entry_6.insert(END,'580.4977')
entry_6.place(
    x=373.0,
    y=140.0,
    width=49.0,
    height=15.0
)

canvas.create_text(
    295.0,
    140.0,
    anchor="nw",
    text="background\nm/z",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

# entry_image_7 = PhotoImage(
#     file=relative_to_assets("entry_7.png"))
# entry_bg_7 = canvas.create_image(
#     258.5,
#     175.5,
#     image=entry_image_7
# )
entry_7 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = resolution_storage
)
entry_7.insert(END,'7000')
entry_7.place(
    x=234.0,
    y=140.0,
    width=49.0,
    height=15.0
)

canvas.create_text(
    163.0,
    140.0,
    anchor="nw",
    text="resolution",
    fill="#000000",
    font=("Inter", 12 * -1)
)

# entry_image_8 = PhotoImage(
#     file=relative_to_assets("entry_8.png"))
# entry_bg_8 = canvas.create_image(
#     119.5,
#     175.5,
#     image=entry_image_8
# )
entry_8 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = intensity_storage
)
entry_8.insert(END,'2000')
entry_8.place(
    x=95.0,
    y=140.0,
    width=49.0,
    height=15.0
)

canvas.create_text(
    24.0,
    135.0,
    anchor="nw",
    text="Intensity\nthreshold",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

# entry_image_9 = PhotoImage(
#     file=relative_to_assets("entry_9.png"))
# entry_bg_9 = canvas.create_image(
#     397.5,
#     131.5,
#     image=entry_image_9
# )
entry_9 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = charge_storage
)
entry_9.place(
    x=373.0,
    y=105.0,
    width=49.0,
    height=15.0
)
entry_9.insert(END,'1')
canvas.create_text(
    325.0,
    105.0,
    anchor="nw",
    text="z",
    fill="#000000",
    font=("Inter", 12 * -1)
)

# entry_image_10 = PhotoImage(
#     file=relative_to_assets("entry_10.png"))
# entry_bg_10 = canvas.create_image(
#     258.5,
#     131.5,
#     image=entry_image_10
# )
entry_10 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = tolerance_storage
)
entry_10.place(
    x=234.0,
    y=105.0,
    width=49.0,
    height=15.0
)
entry_10.insert(END,'0.1')
canvas.create_text(
    165.0,
    105.0,
    anchor="nw",
    text="tolerance",
    fill="#000000",
    font=("Inter", 12 * -1)
)

entry_13 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = median_size_storage
)
entry_13.place(
    x=95.0,
    y=190.0,
    width=49.0,
    height=15.0
)
entry_13.insert(END,'2')
canvas.create_text(
    24.0,
    182.0,
    anchor="nw",
    text="median\nfilter size",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

entry_14 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = bin_step_size_storage
)
entry_14.place(
    x=234.0,
    y=190.0,
    width=49.0,
    height=15.0
)
entry_14.insert(END,'6')
canvas.create_text(
    163.0,
    182.0,
    anchor="nw",
    text="binarize\nstep size",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

# entry_image_11 = PhotoImage(
#     file=relative_to_assets("entry_11.png"))
# entry_bg_11 = canvas.create_image(
#     212.5,
#     336.5,
#     image=entry_image_11
# )
entry_11 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = min_cell_size_storage
)
entry_11.place(
    x=188.0,
    y=300.0,
    width=49.0,
    height=15.0
)
entry_11.insert(END,'50')
# entry_image_12 = PhotoImage(
#     file=relative_to_assets("entry_12.png"))
# entry_bg_12 = canvas.create_image(
#     289.5,
#     336.5,
#     image=entry_image_12
# )
entry_12 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = max_cell_size_storage
)
entry_12.place(
    x=265.0,
    y=300.0,
    width=49.0,
    height=15.0
)
entry_12.insert(END,'300')
canvas.create_text(
    85.0,
    300.0,
    anchor="nw",
    text="Cell area range",
    fill="#000000",
    font=("Inter", 12 * -1)
)

canvas.create_text(
    242.0,
    282.0,
    anchor="nw",
    text="-",
    fill="#000000",
    font=("Inter", 40 * -1)
)

entry_1120 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = min_mz_range
)
entry_1120.place(
    x=188.0,
    y=335.0,
    width=49.0,
    height=15.0
)
min_mz_range.set(600)
# entry_image_12 = PhotoImage(
#     file=relative_to_assets("entry_12.png"))
# entry_bg_12 = canvas.create_image(
#     289.5,
#     336.5,
#     image=entry_image_12
# )
entry_1220 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable = max_mz_range
)
max_mz_range.set(1000)
entry_1220.place(
    x=265.0,
    y=335.0,
    width=49.0,
    height=15.0
)

canvas.create_text(
    82.0,
    325.0,
    anchor="nw",
    text="Average spectra\nm/z range",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)
canvas.create_text(
    242.0,
    318.0,
    anchor="nw",
    text="-",
    fill="#000000",
    font=("Inter", 40 * -1)
)

canvas.create_text(
    300.0,#x
    180.0, #y
    anchor="nw",
    text="weighted\naverage",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)
c1 = Checkbutton(window, variable = weight_avg,onvalue=1, offvalue=0,bg='#D5C9D6')
c1.place(x=373.0,
    y=190.0,
    width=15.0,
    height=15.0
)


canvas.create_rectangle(
    430.0,
    0.0,
    860.0,
    408.0,
    fill="#B19BB3",
    outline="")

canvas.create_text(
    600.0,
    8.0,
    anchor="nw",
    text="Optical Viewer",
    fill="#000000",
    font=("HammersmithOne Regular", 16 * -1,'bold')
)

# entry_image_13 = PhotoImage(
#     file=relative_to_assets("entry_13.png"))
# entry_bg_13 = canvas.create_image(
#     658.0,
#     385.5,
#     image=entry_image_13
# )
entry_13 = Entry(
    bd=0,
    bg="#FFFFFF",
    highlightthickness=0,
    textvariable=optical_path_storage
)
entry_13.place(
    x=500.0,
    y=377.0,
    width=246.0,
    height=15.0
)

button_image_10 = PhotoImage(
    file=relative_to_assets("button_10.png"))
button_10 = Button(
    image=button_image_10,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: set_optical_image_field(),
    relief="flat",
    bg='#B19BB3'
)
button_10.place(
    x=740.0,
    y=377.0,
    width=55.0,
    height=17.0
)



canvas.create_text(
    450.0,
    360.0,
    anchor="nw",
    text="Select\noptical\nimage",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)

microscope_image = PhotoImage(
    file=relative_to_assets("microscope_small.png"))

canvas.create_rectangle(
    465.0,
    44.0,
    825.0,
    352.0,
    fill="#B19BB3",
    outline="")

image_1 = canvas.create_image(
    645.0,
    158.0,
    image=microscope_image
)


canvas.create_text(
    525.0,
    275.0,
    anchor="nw",
    text="Image will display upon selection",
    fill="#000000",
    font=("Inter", 16 * -1)
)

canvas.create_rectangle(
    860.0,
    0.0,
    1290.0,
    408.0,
    fill="#8C6D8F",
    outline="")

canvas.create_text(
    1015.0,
    8.0,
    anchor="nw",
    text="MALDI Image Viewer",
    fill="#000000",
    font=("HammersmithOne Regular", 16 * -1,'bold')
)

# entry_image_14 = PhotoImage(
#     file=relative_to_assets("entry_14.png"))
# entry_bg_14 = canvas.create_image(
#     1088.0,
#     385.5,
#     image=entry_image_14
# )
entry_14 = Entry(
    bd=0,
    bg="#F9F8F9",
    highlightthickness=0,
    textvariable = cell_remove_storage
)
entry_14.place(
    x=940.0,
    y=377.0,
    width=246.0,
    height=15.0
)

button_image_11 = PhotoImage(
    file=relative_to_assets("button_11.png"))
button_11 = Button(
    image=button_image_11,
    borderwidth=0,
    highlightthickness=0,
    command=start_remove_cell_by_number,
    relief="flat",
    bg='#8C6D8F'
)
button_11.place(
    x=1180.0,
    y=377.0,
    width=55.0,
    height=17.0
)

button_image_110 = PhotoImage(
    file=relative_to_assets("button_110.png"))
button_110 = Button(
    image=button_image_110,
    borderwidth=0,
    highlightthickness=0,
    command=optical_pop_out,
    relief="flat",
    bg='#B19BB3'
)
button_110.place(
    x=625.0,
    y=300.0,
    width=55.0,
    height=17.0
)

canvas.create_text(
    885.0,
    360.0,
    anchor="nw",
    text="Remove\ncell by\nnumber",
    fill="#000000",
    font=("Inter", 12 * -1),
    justify='center'
)
tims_image = PhotoImage(
    file=relative_to_assets("maldi_logo.png"))

canvas.create_rectangle(
    895.0,
    44.0,
    1255.0,
    352.0,
    fill="#8C6D8F",
    outline="")

image_2 = canvas.create_image(
    1075.0,
    158.0,
    image=tims_image
)

canvas.create_text(
    960.0,
    275.0,
    anchor="nw",
    text="Image will display upon selection",
    fill="#000000",
    font=("Inter", 16 * -1)
)

canvas.create_text(
    1312.0,
    8.0,
    anchor="nw",
    text="Workflow",
    fill="#000000",
    font=("HammersmithOne Regular", 16 * -1,'bold')
) #1238.0
window.resizable(False, False)
window.mainloop()
